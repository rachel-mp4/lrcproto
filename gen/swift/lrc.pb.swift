// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lrc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Lrc_V1_Event: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var msg: Lrc_V1_Event.OneOf_Msg? = nil

  var ping: Lrc_V1_Ping {
    get {
      if case .ping(let v)? = msg {return v}
      return Lrc_V1_Ping()
    }
    set {msg = .ping(newValue)}
  }

  var pong: Lrc_V1_Pong {
    get {
      if case .pong(let v)? = msg {return v}
      return Lrc_V1_Pong()
    }
    set {msg = .pong(newValue)}
  }

  var init_p: Lrc_V1_Init {
    get {
      if case .init_p(let v)? = msg {return v}
      return Lrc_V1_Init()
    }
    set {msg = .init_p(newValue)}
  }

  var pub: Lrc_V1_Pub {
    get {
      if case .pub(let v)? = msg {return v}
      return Lrc_V1_Pub()
    }
    set {msg = .pub(newValue)}
  }

  var insert: Lrc_V1_Insert {
    get {
      if case .insert(let v)? = msg {return v}
      return Lrc_V1_Insert()
    }
    set {msg = .insert(newValue)}
  }

  var delete: Lrc_V1_Delete {
    get {
      if case .delete(let v)? = msg {return v}
      return Lrc_V1_Delete()
    }
    set {msg = .delete(newValue)}
  }

  var mute: Lrc_V1_Mute {
    get {
      if case .mute(let v)? = msg {return v}
      return Lrc_V1_Mute()
    }
    set {msg = .mute(newValue)}
  }

  var unmute: Lrc_V1_Unmute {
    get {
      if case .unmute(let v)? = msg {return v}
      return Lrc_V1_Unmute()
    }
    set {msg = .unmute(newValue)}
  }

  var set: Lrc_V1_Set {
    get {
      if case .set(let v)? = msg {return v}
      return Lrc_V1_Set()
    }
    set {msg = .set(newValue)}
  }

  var get: Lrc_V1_Get {
    get {
      if case .get(let v)? = msg {return v}
      return Lrc_V1_Get()
    }
    set {msg = .get(newValue)}
  }

  var kick: Lrc_V1_Kick {
    get {
      if case .kick(let v)? = msg {return v}
      return Lrc_V1_Kick()
    }
    set {msg = .kick(newValue)}
  }

  var hug: Lrc_V1_Hug {
    get {
      if case .hug(let v)? = msg {return v}
      return Lrc_V1_Hug()
    }
    set {msg = .hug(newValue)}
  }

  var ban: Lrc_V1_Ban {
    get {
      if case .ban(let v)? = msg {return v}
      return Lrc_V1_Ban()
    }
    set {msg = .ban(newValue)}
  }

  var unban: Lrc_V1_Unban {
    get {
      if case .unban(let v)? = msg {return v}
      return Lrc_V1_Unban()
    }
    set {msg = .unban(newValue)}
  }

  var editbatch: Lrc_V1_EditBatch {
    get {
      if case .editbatch(let v)? = msg {return v}
      return Lrc_V1_EditBatch()
    }
    set {msg = .editbatch(newValue)}
  }

  var mediainit: Lrc_V1_MediaInit {
    get {
      if case .mediainit(let v)? = msg {return v}
      return Lrc_V1_MediaInit()
    }
    set {msg = .mediainit(newValue)}
  }

  var mediapub: Lrc_V1_MediaPub {
    get {
      if case .mediapub(let v)? = msg {return v}
      return Lrc_V1_MediaPub()
    }
    set {msg = .mediapub(newValue)}
  }

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Msg: Equatable, Sendable {
    case ping(Lrc_V1_Ping)
    case pong(Lrc_V1_Pong)
    case init_p(Lrc_V1_Init)
    case pub(Lrc_V1_Pub)
    case insert(Lrc_V1_Insert)
    case delete(Lrc_V1_Delete)
    case mute(Lrc_V1_Mute)
    case unmute(Lrc_V1_Unmute)
    case set(Lrc_V1_Set)
    case get(Lrc_V1_Get)
    case kick(Lrc_V1_Kick)
    case hug(Lrc_V1_Hug)
    case ban(Lrc_V1_Ban)
    case unban(Lrc_V1_Unban)
    case editbatch(Lrc_V1_EditBatch)
    case mediainit(Lrc_V1_MediaInit)
    case mediapub(Lrc_V1_MediaPub)

  }

  init() {}

  fileprivate var _id: UInt32? = nil
}

struct Lrc_V1_Ping: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Pong: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Init: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var nick: String {
    get {return _nick ?? String()}
    set {_nick = newValue}
  }
  /// Returns true if `nick` has been explicitly set.
  var hasNick: Bool {return self._nick != nil}
  /// Clears the value of `nick`. Subsequent reads from it will return its default value.
  mutating func clearNick() {self._nick = nil}

  var externalID: String {
    get {return _externalID ?? String()}
    set {_externalID = newValue}
  }
  /// Returns true if `externalID` has been explicitly set.
  var hasExternalID: Bool {return self._externalID != nil}
  /// Clears the value of `externalID`. Subsequent reads from it will return its default value.
  mutating func clearExternalID() {self._externalID = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var echoed: Bool {
    get {return _echoed ?? false}
    set {_echoed = newValue}
  }
  /// Returns true if `echoed` has been explicitly set.
  var hasEchoed: Bool {return self._echoed != nil}
  /// Clears the value of `echoed`. Subsequent reads from it will return its default value.
  mutating func clearEchoed() {self._echoed = nil}

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
  fileprivate var _nick: String? = nil
  fileprivate var _externalID: String? = nil
  fileprivate var _color: UInt32? = nil
  fileprivate var _echoed: Bool? = nil
  fileprivate var _nonce: Data? = nil
}

struct Lrc_V1_Pub: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
}

struct Lrc_V1_Insert: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var body: String = String()

  var utf16Index: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
}

struct Lrc_V1_Delete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var utf16Start: UInt32 = 0

  var utf16End: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
}

struct Lrc_V1_Mute: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Unmute: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Set: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nick: String {
    get {return _nick ?? String()}
    set {_nick = newValue}
  }
  /// Returns true if `nick` has been explicitly set.
  var hasNick: Bool {return self._nick != nil}
  /// Clears the value of `nick`. Subsequent reads from it will return its default value.
  mutating func clearNick() {self._nick = nil}

  var externalID: String {
    get {return _externalID ?? String()}
    set {_externalID = newValue}
  }
  /// Returns true if `externalID` has been explicitly set.
  var hasExternalID: Bool {return self._externalID != nil}
  /// Clears the value of `externalID`. Subsequent reads from it will return its default value.
  mutating func clearExternalID() {self._externalID = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _nick: String? = nil
  fileprivate var _externalID: String? = nil
  fileprivate var _color: UInt32? = nil
}

struct Lrc_V1_Get: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var topic: String {
    get {return _topic ?? String()}
    set {_topic = newValue}
  }
  /// Returns true if `topic` has been explicitly set.
  var hasTopic: Bool {return self._topic != nil}
  /// Clears the value of `topic`. Subsequent reads from it will return its default value.
  mutating func clearTopic() {self._topic = nil}

  var connected: UInt32 {
    get {return _connected ?? 0}
    set {_connected = newValue}
  }
  /// Returns true if `connected` has been explicitly set.
  var hasConnected: Bool {return self._connected != nil}
  /// Clears the value of `connected`. Subsequent reads from it will return its default value.
  mutating func clearConnected() {self._connected = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _topic: String? = nil
  fileprivate var _connected: UInt32? = nil
}

struct Lrc_V1_Sudo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var externalID: String = String()

  var secret: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Kick: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var privileges: Lrc_V1_Sudo {
    get {return _privileges ?? Lrc_V1_Sudo()}
    set {_privileges = newValue}
  }
  /// Returns true if `privileges` has been explicitly set.
  var hasPrivileges: Bool {return self._privileges != nil}
  /// Clears the value of `privileges`. Subsequent reads from it will return its default value.
  mutating func clearPrivileges() {self._privileges = nil}

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _privileges: Lrc_V1_Sudo? = nil
}

struct Lrc_V1_Hug: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_Ban: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var privileges: Lrc_V1_Sudo {
    get {return _privileges ?? Lrc_V1_Sudo()}
    set {_privileges = newValue}
  }
  /// Returns true if `privileges` has been explicitly set.
  var hasPrivileges: Bool {return self._privileges != nil}
  /// Clears the value of `privileges`. Subsequent reads from it will return its default value.
  mutating func clearPrivileges() {self._privileges = nil}

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _privileges: Lrc_V1_Sudo? = nil
}

struct Lrc_V1_Unban: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var privileges: Lrc_V1_Sudo {
    get {return _privileges ?? Lrc_V1_Sudo()}
    set {_privileges = newValue}
  }
  /// Returns true if `privileges` has been explicitly set.
  var hasPrivileges: Bool {return self._privileges != nil}
  /// Clears the value of `privileges`. Subsequent reads from it will return its default value.
  mutating func clearPrivileges() {self._privileges = nil}

  var id: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _privileges: Lrc_V1_Sudo? = nil
}

struct Lrc_V1_Edit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var edit: Lrc_V1_Edit.OneOf_Edit? = nil

  var insert: Lrc_V1_Insert {
    get {
      if case .insert(let v)? = edit {return v}
      return Lrc_V1_Insert()
    }
    set {edit = .insert(newValue)}
  }

  var delete: Lrc_V1_Delete {
    get {
      if case .delete(let v)? = edit {return v}
      return Lrc_V1_Delete()
    }
    set {edit = .delete(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Edit: Equatable, Sendable {
    case insert(Lrc_V1_Insert)
    case delete(Lrc_V1_Delete)

  }

  init() {}
}

struct Lrc_V1_EditBatch: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var edits: [Lrc_V1_Edit] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Lrc_V1_MediaInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var nick: String {
    get {return _nick ?? String()}
    set {_nick = newValue}
  }
  /// Returns true if `nick` has been explicitly set.
  var hasNick: Bool {return self._nick != nil}
  /// Clears the value of `nick`. Subsequent reads from it will return its default value.
  mutating func clearNick() {self._nick = nil}

  var externalID: String {
    get {return _externalID ?? String()}
    set {_externalID = newValue}
  }
  /// Returns true if `externalID` has been explicitly set.
  var hasExternalID: Bool {return self._externalID != nil}
  /// Clears the value of `externalID`. Subsequent reads from it will return its default value.
  mutating func clearExternalID() {self._externalID = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var echoed: Bool {
    get {return _echoed ?? false}
    set {_echoed = newValue}
  }
  /// Returns true if `echoed` has been explicitly set.
  var hasEchoed: Bool {return self._echoed != nil}
  /// Clears the value of `echoed`. Subsequent reads from it will return its default value.
  mutating func clearEchoed() {self._echoed = nil}

  var nonce: Data {
    get {return _nonce ?? Data()}
    set {_nonce = newValue}
  }
  /// Returns true if `nonce` has been explicitly set.
  var hasNonce: Bool {return self._nonce != nil}
  /// Clears the value of `nonce`. Subsequent reads from it will return its default value.
  mutating func clearNonce() {self._nonce = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
  fileprivate var _nick: String? = nil
  fileprivate var _externalID: String? = nil
  fileprivate var _color: UInt32? = nil
  fileprivate var _echoed: Bool? = nil
  fileprivate var _nonce: Data? = nil
}

struct Lrc_V1_MediaPub: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var contentAddress: String {
    get {return _contentAddress ?? String()}
    set {_contentAddress = newValue}
  }
  /// Returns true if `contentAddress` has been explicitly set.
  var hasContentAddress: Bool {return self._contentAddress != nil}
  /// Clears the value of `contentAddress`. Subsequent reads from it will return its default value.
  mutating func clearContentAddress() {self._contentAddress = nil}

  var alt: String {
    get {return _alt ?? String()}
    set {_alt = newValue}
  }
  /// Returns true if `alt` has been explicitly set.
  var hasAlt: Bool {return self._alt != nil}
  /// Clears the value of `alt`. Subsequent reads from it will return its default value.
  mutating func clearAlt() {self._alt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _id: UInt32? = nil
  fileprivate var _contentAddress: String? = nil
  fileprivate var _alt: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "lrc.v1"

extension Lrc_V1_Event: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Event"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ping\0\u{1}pong\0\u{1}init\0\u{1}pub\0\u{1}insert\0\u{1}delete\0\u{1}mute\0\u{1}unmute\0\u{1}set\0\u{1}get\0\u{1}kick\0\u{1}hug\0\u{1}ban\0\u{1}unban\0\u{1}editbatch\0\u{1}id\0\u{1}mediainit\0\u{1}mediapub\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lrc_V1_Ping?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .ping(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .ping(v)
        }
      }()
      case 2: try {
        var v: Lrc_V1_Pong?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .pong(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .pong(v)
        }
      }()
      case 3: try {
        var v: Lrc_V1_Init?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .init_p(v)
        }
      }()
      case 4: try {
        var v: Lrc_V1_Pub?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .pub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .pub(v)
        }
      }()
      case 5: try {
        var v: Lrc_V1_Insert?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .insert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .insert(v)
        }
      }()
      case 6: try {
        var v: Lrc_V1_Delete?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .delete(v)
        }
      }()
      case 7: try {
        var v: Lrc_V1_Mute?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .mute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .mute(v)
        }
      }()
      case 8: try {
        var v: Lrc_V1_Unmute?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .unmute(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .unmute(v)
        }
      }()
      case 9: try {
        var v: Lrc_V1_Set?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .set(v)
        }
      }()
      case 10: try {
        var v: Lrc_V1_Get?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .get(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .get(v)
        }
      }()
      case 11: try {
        var v: Lrc_V1_Kick?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .kick(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .kick(v)
        }
      }()
      case 12: try {
        var v: Lrc_V1_Hug?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .hug(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .hug(v)
        }
      }()
      case 13: try {
        var v: Lrc_V1_Ban?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .ban(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .ban(v)
        }
      }()
      case 14: try {
        var v: Lrc_V1_Unban?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .unban(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .unban(v)
        }
      }()
      case 15: try {
        var v: Lrc_V1_EditBatch?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .editbatch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .editbatch(v)
        }
      }()
      case 16: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 17: try {
        var v: Lrc_V1_MediaInit?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .mediainit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .mediainit(v)
        }
      }()
      case 18: try {
        var v: Lrc_V1_MediaPub?
        var hadOneofValue = false
        if let current = self.msg {
          hadOneofValue = true
          if case .mediapub(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.msg = .mediapub(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.msg {
    case .ping?: try {
      guard case .ping(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .pong?: try {
      guard case .pong(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .init_p?: try {
      guard case .init_p(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .pub?: try {
      guard case .pub(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .insert?: try {
      guard case .insert(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .mute?: try {
      guard case .mute(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .unmute?: try {
      guard case .unmute(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .set?: try {
      guard case .set(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .get?: try {
      guard case .get(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .kick?: try {
      guard case .kick(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .hug?: try {
      guard case .hug(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .ban?: try {
      guard case .ban(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .unban?: try {
      guard case .unban(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .editbatch?: try {
      guard case .editbatch(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    default: break
    }
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 16)
    } }()
    switch self.msg {
    case .mediainit?: try {
      guard case .mediainit(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .mediapub?: try {
      guard case .mediapub(let v)? = self.msg else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    default: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Event, rhs: Lrc_V1_Event) -> Bool {
    if lhs.msg != rhs.msg {return false}
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Ping: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ping"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Ping, rhs: Lrc_V1_Ping) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Pong: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pong"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Pong, rhs: Lrc_V1_Pong) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Init: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Init"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}nick\0\u{1}externalID\0\u{1}color\0\u{1}echoed\0\u{1}nonce\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nick) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._externalID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._color) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._echoed) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nick {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._externalID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._echoed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Init, rhs: Lrc_V1_Init) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._nick != rhs._nick {return false}
    if lhs._externalID != rhs._externalID {return false}
    if lhs._color != rhs._color {return false}
    if lhs._echoed != rhs._echoed {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Pub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Pub"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Pub, rhs: Lrc_V1_Pub) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Insert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Insert"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}body\0\u{1}utf16Index\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.body) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.utf16Index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if !self.body.isEmpty {
      try visitor.visitSingularStringField(value: self.body, fieldNumber: 2)
    }
    if self.utf16Index != 0 {
      try visitor.visitSingularUInt32Field(value: self.utf16Index, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Insert, rhs: Lrc_V1_Insert) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.body != rhs.body {return false}
    if lhs.utf16Index != rhs.utf16Index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Delete"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}utf16Start\0\u{1}utf16End\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.utf16Start) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.utf16End) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    if self.utf16Start != 0 {
      try visitor.visitSingularUInt32Field(value: self.utf16Start, fieldNumber: 2)
    }
    if self.utf16End != 0 {
      try visitor.visitSingularUInt32Field(value: self.utf16End, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Delete, rhs: Lrc_V1_Delete) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.utf16Start != rhs.utf16Start {return false}
    if lhs.utf16End != rhs.utf16End {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Mute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Mute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Mute, rhs: Lrc_V1_Mute) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Unmute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unmute"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Unmute, rhs: Lrc_V1_Unmute) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Set"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}nick\0\u{1}externalID\0\u{1}color\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nick) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._externalID) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._color) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._nick {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._externalID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Set, rhs: Lrc_V1_Set) -> Bool {
    if lhs._nick != rhs._nick {return false}
    if lhs._externalID != rhs._externalID {return false}
    if lhs._color != rhs._color {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Get: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Get"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}topic\0\u{1}connected\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._topic) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._connected) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._topic {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._connected {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Get, rhs: Lrc_V1_Get) -> Bool {
    if lhs._topic != rhs._topic {return false}
    if lhs._connected != rhs._connected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Sudo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Sudo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}externalID\0\u{1}secret\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.externalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.secret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.externalID.isEmpty {
      try visitor.visitSingularStringField(value: self.externalID, fieldNumber: 1)
    }
    if !self.secret.isEmpty {
      try visitor.visitSingularStringField(value: self.secret, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Sudo, rhs: Lrc_V1_Sudo) -> Bool {
    if lhs.externalID != rhs.externalID {return false}
    if lhs.secret != rhs.secret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Kick: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Kick"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}privileges\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._privileges) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._privileges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Kick, rhs: Lrc_V1_Kick) -> Bool {
    if lhs._privileges != rhs._privileges {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Hug: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Hug"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Hug, rhs: Lrc_V1_Hug) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Ban: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ban"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}privileges\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._privileges) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._privileges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Ban, rhs: Lrc_V1_Ban) -> Bool {
    if lhs._privileges != rhs._privileges {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Unban: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Unban"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}privileges\0\u{1}id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._privileges) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._privileges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.id != 0 {
      try visitor.visitSingularUInt32Field(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Unban, rhs: Lrc_V1_Unban) -> Bool {
    if lhs._privileges != rhs._privileges {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_Edit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Edit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}insert\0\u{1}delete\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lrc_V1_Insert?
        var hadOneofValue = false
        if let current = self.edit {
          hadOneofValue = true
          if case .insert(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.edit = .insert(v)
        }
      }()
      case 2: try {
        var v: Lrc_V1_Delete?
        var hadOneofValue = false
        if let current = self.edit {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.edit = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.edit {
    case .insert?: try {
      guard case .insert(let v)? = self.edit else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.edit else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_Edit, rhs: Lrc_V1_Edit) -> Bool {
    if lhs.edit != rhs.edit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_EditBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EditBatch"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}edits\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.edits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.edits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.edits, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_EditBatch, rhs: Lrc_V1_EditBatch) -> Bool {
    if lhs.edits != rhs.edits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_MediaInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaInit"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}nick\0\u{1}externalID\0\u{1}color\0\u{1}echoed\0\u{1}nonce\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nick) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._externalID) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._color) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._echoed) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._nonce) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._nick {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._externalID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._echoed {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._nonce {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_MediaInit, rhs: Lrc_V1_MediaInit) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._nick != rhs._nick {return false}
    if lhs._externalID != rhs._externalID {return false}
    if lhs._color != rhs._color {return false}
    if lhs._echoed != rhs._echoed {return false}
    if lhs._nonce != rhs._nonce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Lrc_V1_MediaPub: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MediaPub"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{1}contentAddress\0\u{1}alt\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contentAddress) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._alt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._contentAddress {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._alt {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Lrc_V1_MediaPub, rhs: Lrc_V1_MediaPub) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._contentAddress != rhs._contentAddress {return false}
    if lhs._alt != rhs._alt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
